function [sigDEN_r, wDEC_r, wDEC_nonFiltered_r, validityFlag] = func_denoise_sw1d(file, config)
% FUNC_DENOISE_SW1D Saved Denoising Process.
%   
%   -------------------
%   sigDEN_r: vector of denoised data
%   wDEC_r: filtered stationary wavelet decomposition
%   wDEC_nonFiltered_r: non filtered stationary wavelet decomposition

%  Auto-generated by Wavelet Toolbox on 14-Jul-2017 14:54:08
% Analysis parameters.

% Developer : 
% Date :      
% Modified:   A. Bourak 11/08/2017

%% ______________________ Set default parameters _______________________ %%
SIG = file.signal;
Fs = file.Fs;
wname = config.waveletDenoising.wname;
deviceType = config.waveletDenoising.deviceType;
level = str2double(config.waveletDenoising.level);
signalLength = length(SIG);
if isempty(wname)
    wname = 'sym7'; 
end
% if isemty(level) %Temporary unused
    if deviceType == '1'
        level = 5;
    elseif deviceType == '2'
        level = 10;
    else
        disp('ERROR! Wrong device!');
        return;
    end
% end

% meth = 'sqtwolog';
% scal_OR_alfa = one;



% adding trailing zeros to satisfy needed signal length requirement
multiplicityFactor = 2^level;
neededSignalLength = ceil(signalLength/multiplicityFactor) * multiplicityFactor;

if (neededSignalLength > signalLength)
    numOfAddedSamples = neededSignalLength - signalLength;
    SIG = [SIG; zeros(numOfAddedSamples, 1)];
end




%% ____________________ Decompose using SWT ____________________________ %%

wDEC = swt(SIG,level,wname);
wDEC_nonFiltered = wDEC;
wDECSize = size(wDEC);
wDECNumbers = wDECSize(1);


%% ___________________ Denoising parameters ____________________________ %%

sorh = 's';    % Specified soft or hard thresholding

%% ________________ Setting noise treshold level _______________________ %%

for k = 1:wDECNumbers
    
    [noiseSTD(k)] = getNoiseSignalTroughEntropy(wDEC(k, :), Fs, deviceType);
    
    currentSignal = wDEC(k, :);
    
    noiseTreshold(k) = noiseSTD(k)*sqrt(2*log(length(currentSignal)));

end

switch deviceType
    case '1'
        thrSettings =  {...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 1); ...
            ]; ...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 2); ...
            ]; ...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 3); ...
            ]; ...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 4); ...
            ]; ...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 5); ...
            ]; ...
            };
    case '2'
        thrSettings =  {...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 1); ...
            ]; ...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 2); ...
            ]; ...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 3); ...
            ]; ...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 4); ...
            ]; ...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 5); ...
            ]; ...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 6); ...
            ]; ...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 7); ...
            ]; ...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 8); ...
            ]; ...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 9); ...
            ]; ...
            [...
            1.000000000000000  signalLength      noiseTreshold(1, 10); ...
            ]; ...
            };
end

%% __________________________ Denoise __________________________________ %%

len = length(SIG);
for k = 1:level
    thr_par = thrSettings{k};
    [~, ~, validityFlag(k)] = windowKurtosis(wDEC(k, :), Fs);
%     thr_par = thselect(wDEC(k),'sqtwolog');
    if ~isempty(thr_par)
        NB_int = size(thr_par,1);
        x      = [thr_par(:,1) ; thr_par(NB_int,2)];
        x      = round(x);
        x(x<1) = 1;
        x(x>len) = len;
        thr = thr_par(:,3);
        for j = 1:NB_int
            if j==1 , d_beg = 0; else d_beg = 1; end
            j_beg = x(j)+d_beg;
            j_end = x(j+1);
            j_ind = (j_beg:j_end);
            wDEC(k,j_ind) = wthresh(wDEC(k,j_ind),sorh,thr(j));
%             wDEC(k,j_ind) = wthresh_our(wDEC(k,j_ind),sorh,thr1(j),thr2(j));              %Filter in range
           
        end
        
    end
end

%% __________ Reconstruct the denoise signal using ISWT _________________%%

j = 1;
for i = 1:level
    if validityFlag(i) == 1
        wDECValid(j, :) = wDEC(i, :);
        j = j + 1;
    else 
        errStr = sprintf('Level %d is not valid', i);
        disp(errStr);
    end
    if nnz(~validityFlag) == numel(validityFlag)
        wDECValid(i,:) = wDEC(i,:);
    end
end

if nnz(~validityFlag) == numel(validityFlag) 
        disp('Reconstructing signal through all filtered coefficients');
end
    
    sigDEN = iswt(wDECValid,wname);
    
    


%returned values
sigDEN_r = sigDEN(1:signalLength);
wDEC_r = wDEC(:,1:signalLength);
wDEC_nonFiltered_r = wDEC_nonFiltered(:,1:signalLength);

end


function [resultedNoiseSTD] = getNoiseSignalTroughEntropy(signal, Fs, deviceType)
    winLength = 0.10; %in seconds
    winStep = 0.01; %in seconds
    numOfShortBlocks = 5;
    
    signalLength = length(signal);
    dt = 1/Fs;
    tmax = dt*signalLength;
    t = 0:dt:tmax-dt;
    
    Entropy = [];
    [Entropy] = energyEntropyBlock(signal,winLength*Fs,winStep*Fs,numOfShortBlocks);

    entropySize = length(Entropy);

    % dtEnt = dt * signalLength / entropySize;
    % tEnt = 0:dtEnt:tmax-dtEnt;

    dtEnt = winStep;
    leadingTrailingSpace = winLength/2;
    tEnt = leadingTrailingSpace:dtEnt:tmax-leadingTrailingSpace;

%     plot(tEnt, Entropy, 'r');



    %% =================== Finding Standard Deviation of Noise ================ %%
    switch deviceType
        case '1'
            cutoffLevel = 0.01;
        case '2'
            cutoffLevel = 0.001;
    end
    isNoiseBegun = 0;
    dtEntToDt = dtEnt / dt;

    noiseExcerpts = {};
    numOfNoiseExcerpts = 1;

    tStart = 0;
    tEnd = 0;
    
    for i = 1:entropySize

        curEntropy = Entropy(i);
        if curEntropy < cutoffLevel

            if ~isNoiseBegun 

                isNoiseBegun = 1;
                tStart = i * dtEntToDt;
                startIndex = round(tStart);

            end
        else
            if isNoiseBegun

               tEnd  = i * dtEntToDt;

               endIndex = round(tEnd);

               noiseExcerpts{numOfNoiseExcerpts} = signal(startIndex : endIndex);           
               numOfNoiseExcerpts = numOfNoiseExcerpts + 1;
               isNoiseBegun = 0;

            end
        end
    end

    noiseExcerpts = noiseExcerpts';

    % plot all the extracted noise excerpts
%     for i = 1:numOfNoiseExcerpts-1
%         figure, plot(noiseExcerpts{i});
%     end
%     title('Extracted Noise Excerpts');

    % noise STD calculation
    if numOfNoiseExcerpts>1
        summarizedSTD = 0;
        for i = 1:numOfNoiseExcerpts-1
            noiseSTD = std(noiseExcerpts{i});
            summarizedSTD = summarizedSTD + noiseSTD;
        end
        resultedNoiseSTD = summarizedSTD / (numOfNoiseExcerpts-1);
    else
        resultedNoiseSTD = 0;
    end
end

% Thirdparty function for entropy of energy calculation
%
% Taken from https://www.mathworks.com/matlabcentral/fileexchange/19236-some-basic-audio-features
%
function [Entropy] = energyEntropyBlock(f,winLength,winStep,numOfShortBlocks)

Entropy = [];
f = f / max(abs(f));
Eol = sum(f.^2);
L = length(f);

if (winLength==0)
    winLength = floor(L);
    winStep = floor(L);
end


numOfBlocks = (L-winLength)/winStep + 1;
curPos = 1;
for (i=1:numOfBlocks)
    curBlock = f(curPos:curPos+winLength-1);
    for (j=1:numOfShortBlocks)        
        s(j) = sum(curBlock((j-1)*(winLength/numOfShortBlocks)+1:j*(winLength/numOfShortBlocks)).^2)/Eol;
    end
    
    Entropy(i) = -sum(s.*log2(s));
    curPos = curPos + winStep;
end

end 
